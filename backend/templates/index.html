<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Atlas Chat Interface</title>
    
    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700&family=Audiowide&display=swap" rel="stylesheet">
    
    <!-- CSS Modules with cache busting -->
    <link rel="stylesheet" href="{{ url_for('static', filename='css/base.css') }}?v={{ range(1, 10000) | random }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/layout.css') }}?v={{ range(1, 10000) | random }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/components.css') }}?v={{ range(1, 10000) | random }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/animations.css') }}?v={{ range(1, 10000) | random }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/atlas_v2.css') }}?v={{ range(1, 10000) | random }}">
    
    <style>
        /* Attachment area styling */
        .attachment-area {
            padding-bottom: 10px;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .preview-item {
            width: 90px;
            height: 90px;
            background-color: #2A2B32;
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 4px;
            overflow: hidden;
            position: relative;
        }

        .preview-item .preview-thumbnail {
            width: 100%;
            height: 100%;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #2A2B32;
        }

        .preview-item:hover::after {
            content: '';
            position: absolute;
            inset: 0;
            background: rgba(0,0,0,0.3);
            pointer-events: none;
        }

        .preview-item .preview-thumbnail img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .preview-item .preview-thumbnail svg {
            width: 32px;
            height: 32px;
            color: #ECECF1;
        }

        .file-type-indicator {
            position: absolute;
            bottom: 2px;
            right: 2px;
            background-color: rgba(52,53,65,0.9);
            padding: 1px 4px;
            border-radius: 3px;
            font-size: 9px;
            color: #ECECF1;
            border: 1px solid rgba(255,255,255,0.1);
            z-index: 1;
        }

        .preview-close-btn {
            position: absolute;
            top: 2px;
            right: 2px;
            width: 16px;
            height: 16px;
            border-radius: 3px;
            background: rgba(52,53,65,0.9);
            border: 1px solid rgba(255,255,255,0.1);
            color: #ECECF1;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 2;
            padding: 0;
        }

        .preview-close-btn:hover {
            background-color: rgba(32,33,35,0.9);
        }

        .preview-close-btn svg {
            width: 14px;
            height: 14px;
        }

        /* ChatGPT-style Compact Message Preview */
        .compact-preview-message {
            display: flex !important;
            align-items: center !important;
            gap: 10px !important;
            background: rgba(0,0,0,0.1) !important;
            padding: 8px !important;
            border-radius: 5px !important;
            border: 1px solid rgba(255,255,255,0.1) !important;
            width: fit-content !important;
            max-width: 300px !important;
            margin: 4px 0 !important;
        }

        .compact-preview-img {
            width: 70px !important;
            height: 70px !important;
            border-radius: 5px !important;
            object-fit: cover !important;
            flex-shrink: 0 !important;
            border: 1px solid rgba(255,255,255,0.1) !important;
        }

        .compact-preview-info {
            display: flex !important;
            flex-direction: column !important;
            gap: 4px !important;
            min-width: 0 !important;
            padding: 2px 0 !important;
        }

        .compact-preview-name {
            font-size: 13px !important;
            color: rgba(255,255,255,0.9) !important;
            white-space: nowrap !important;
            overflow: hidden !important;
            text-overflow: ellipsis !important;
            font-weight: 500 !important;
        }

        .compact-preview-type {
            font-size: 12px !important;
            color: rgba(255,255,255,0.5) !important;
            display: flex !important;
            align-items: center !important;
            gap: 4px !important;
        }

        .compact-preview-type::before {
            content: "ðŸ“„" !important;
            font-size: 12px !important;
        }

        .message-text .compact-preview-message {
            margin: 4px 0 !important;
        }

        /* CRITICAL: Force message layout - OVERRIDE EVERYTHING */
        .chat-messages {
            display: flex !important;
            flex-direction: column !important;
            gap: 0 !important;
            padding: 24px !important;
        }
        
        .message,
        .user-message,
        .ai-message,
        .bot {
            display: flex !important;
            flex-direction: column !important;
            margin-bottom: 24px !important;
            width: 100% !important;
            align-items: flex-start !important;
        }
        
        .user-message {
            align-items: flex-end !important;
        }
        
        .message-content {
            display: flex !important;
            flex-direction: row !important;
            align-items: flex-start !important;
            gap: 12px !important;
            max-width: 65% !important;
        }
        
        .user-message .message-content {
            flex-direction: row-reverse !important;
        }
        
        .message-avatar {
            width: 40px !important;
            height: 40px !important;
            min-width: 40px !important;
            border-radius: 50% !important;
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
            font-weight: 600 !important;
            font-size: 14px !important;
            flex-shrink: 0 !important;
        }
        
        .message-avatar svg {
            width: 20px !important;
            height: 20px !important;
            stroke: #00d9ff !important; /* Bright cyan color */
            filter: brightness(1.3) !important; /* Make it brighter */
        }
        
        .ai-message .message-avatar {
            background: linear-gradient(135deg, #1e3a8a 0%, #1e40af 100%) !important; /* Deep blue gradient */
            color: white !important;
        }
        
        .user-message .message-avatar {
            background: linear-gradient(135deg, #06b6d4 0%, #0891b2 100%) !important; /* Cyan gradient */
            color: white !important;
        }
        
        .message-text {
            padding: 12px 16px !important;
            border-radius: 16px !important;
            line-height: 1.6 !important;
            word-wrap: break-word !important;
            flex: 1 !important;
        }
        
        .user-message .message-text {
            background: linear-gradient(135deg, #3b82f6, #2563eb) !important;
            color: #ffffff !important;
            border-radius: 16px 16px 2px 16px !important;
        }
        
        .ai-message .message-text {
            background: rgba(30, 30, 30, 0.95) !important;
            color: #e5e7eb !important;
            border: 1px solid rgba(255, 255, 255, 0.08) !important;
            border-radius: 16px 16px 16px 2px !important;
        }
        
        .message-time {
            display: block !important;
            font-size: 10px !important;
            color: rgba(255, 255, 255, 0.4) !important;
            margin-top: 4px !important;
            padding-left: 52px !important;
        }
        
        .user-message .message-time {
            padding-left: 0 !important;
            padding-right: 52px !important;
            text-align: right !important;
        }
    </style>
</head>
<body>
    <!-- Starry Background -->
    <div class="starry-background">
        <div class="stars" id="stars"></div>
    </div>

    <!-- Main App -->
    <div class="app-container">
        <!-- Sidebar -->
        <aside class="sidebar" id="sidebar">
            <button class="toggle-btn" id="toggleBtn" aria-label="Toggle sidebar">
                <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M15 18l-6-6 6-6"/>
                </svg>
            </button>

            <div class="logo-section">
                <div class="logo">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M21 12a9 9 0 01-9 9m9-9a9 9 0 00-9-9m9 9H3m9 9a9 9 0 01-9-9m9 9c1.657 0 3-4.5 3-9s-1.343-9-3-9m-9 9a9 9 0 019 9m-9-9a9 9 0 009-9m-9 9h12"/>
                    </svg>
                </div>
                <span class="logo-text">Atlas</span>
            </div>

            <nav class="nav-section">
                <a href="/chat" class="nav-item active" data-mode="chat">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/>
                    </svg>
                    <span class="nav-text">Chat</span>
                </a>
                <a href="/chat?mode=debate" class="nav-item" data-mode="debate">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M13 2L3 14h9l-1 8 10-12h-9l1-8z"/>
                    </svg>
                    <span class="nav-text">Debate</span>
                </a>
                <div class="nav-item">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"/>
                    </svg>
                    <span class="nav-text">Tasks</span>
                </div>
                <div class="nav-item">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="9"></circle>
                        <polyline points="12 7 12 12 16 14"></polyline>
                    </svg>
                    <span class="nav-text">History</span>
                </div>
                <div class="nav-item">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="3"/>
                        <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06-.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"/>
                    </svg>
                    <span class="nav-text">Settings</span>
                </div>
            </nav>
        </aside>

        <!-- Chat Container -->
        <main class="chat-container">
            <div class="mobile-header" style="display: none;">
                <button class="menu-btn" id="mobileMenuBtn">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="3" y1="6" x2="21" y2="6"/>
                        <line x1="3" y1="12" x2="21" y2="12"/>
                        <line x1="3" y1="18" x2="21" y2="18"/>
                    </svg>
                </button>
                <span class="chat-title">Atlas Chat</span>
            </div>

            <header class="chat-header">
                <h1 class="chat-title" id="chatTitle">Chat with Atlas</h1>
                <div style="display: flex; align-items: center; gap: 12px;">
                    <span style="color: rgba(255,255,255,0.7); font-size: 13px; font-weight: 600;">v2.0 Enhanced Analysis</span>
                    <label style="position: relative; display: inline-block; width: 50px; height: 24px;">
                        <input type="checkbox" id="v2Toggle" style="opacity: 0; width: 0; height: 0;">
                        <span style="position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(255,255,255,0.2); transition: 0.3s; border-radius: 24px;">
                            <span id="v2ToggleSlider" style="position: absolute; content: ''; height: 18px; width: 18px; left: 3px; bottom: 3px; background-color: white; transition: 0.3s; border-radius: 50%;"></span>
                        </span>
                    </label>
                </div>
            </header>

            <div class="chat-messages" id="chatMessages">
                <!-- Remove all static content - keep div empty -->
            </div>

            <div class="input-container">
                <div id="attachmentArea" class="attachment-area"></div>
                <div class="input-toolbar">
                    <div class="toolbar-left">
                        <div class="attachment-container">
                            <button class="input-btn" id="attachBtn">
                                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <path d="M12 5v14m-7-7h14" />
                                </svg>
                            </button>
                            <div class="attachment-menu" id="attachmentMenu">
                                <button class="menu-item" id="uploadFileBtn">
                                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                                        <polyline points="17 8 12 3 7 8"/>
                                        <line x1="12" y1="3" x2="12" y2="15"/>
                                    </svg>
                                    <span>Upload File</span>
                                </button>
                                <button class="menu-item" id="addLinkBtn">
                                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.72"/>
                                        <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.72-1.72"/>
                                    </svg>
                                    <span>Add Link</span>
                                </button>
                            </div>
                        </div>
                    </div>
                    <div class="toolbar-right">
                        <span class="model-name send-text">SEND</span>
                        <button class="input-btn send-btn" id="sendBtn">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <line x1="22" y1="2" x2="11" y2="13"/>
                                <polygon points="22 2 15 22 11 13 2 9 22 2"/>
                            </svg>
                        </button>
                    </div>
                </div>
                <div class="input-wrapper">
                    <input type="text" class="message-input" id="messageInput" placeholder="Message Atlas..." />
                    <button class="input-btn mic-btn" id="micBtn" aria-label="Voice input">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/>
                            <path d="M19 10v2a7 7 0 0 1-14 0v-2"/>
                            <line x1="12" y1="19" x2="12" y2="23"/>
                            <line x1="8" y1="23" x2="16" y2="23"/>
                        </svg>
                    </button>
                </div>
            </div>
        </main>
    </div>

    <!-- Link Modal -->
    <div id="linkModal" class="modal-overlay">
        <div class="modal-content">
            <h2>Add a Link</h2>
            <input type="text" id="linkInput" placeholder="https://example.com">
            <div class="modal-buttons">
                <button id="closeModalBtn">Cancel</button>
                <button id="submitLinkBtn">Add Link</button>
            </div>
        </div>
    </div>

    <!-- JavaScript Modules -->
    <script>
    // API Module with detailed logging
    const API = {
        baseURL: 'http://127.0.0.1:5000', // Changed from 5000

        async sendMessage(message, mode = 'analytical') {
            console.log('=== API Call ===');
            console.log('Message:', message);
            console.log('Mode:', mode);
            
            try {
                const response = await fetch(`${this.baseURL}/analyze_topic`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ topic: message, model: 'llama3' })
                });
                
                console.log('Response status:', response.status);
                console.log('Response ok:', response.ok);
                
                const responseText = await response.text();
                console.log('Response text:', responseText);
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}, body: ${responseText}`);
                }
                
                const data = JSON.parse(responseText);
                console.log('Parsed data:', data);
                return data;
                
            } catch (error) {
                console.error('=== API Error ===');
                console.error('Error details:', error);
                throw error;
            }
        }
    };

    // Messages Module
    const Messages = {
        container: null,

        init(containerSelector) {
            this.container = document.querySelector(containerSelector);
        },

        addUserMessage(text) {
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message user-message';
            messageDiv.innerHTML = `
                <div class="message-content">
                    <div class="message-avatar">You</div>
                    <div class="message-text">${this.escapeHtml(text)}</div>
                </div>
                <div class="message-time">${this.getTimeString()}</div>
            `;
            this.container.appendChild(messageDiv);
            this.scrollToBottom();
        },

        addUserMessageWithHTML(htmlContent) {
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message user-message';
            messageDiv.innerHTML = `
                <div class="message-content">
                    <div class="message-avatar">You</div>
                    <div class="message-text">${htmlContent}</div>
                </div>
                <div class="message-time">${this.getTimeString()}</div>
            `;
            this.container.appendChild(messageDiv);
            this.scrollToBottom();
        },

        addAIMessage(text) {
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message ai-message';
            messageDiv.innerHTML = `
                <div class="message-content">
                    <div class="message-avatar">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M21 12a9 9 0 01-9 9m9-9a9 9 0 00-9-9m9 9H3m9 9a9 9 0 01-9-9m9 9c1.657 0 3-4.5 3-9s-1.343-9-3-9m-9 9a9 9 0 019 9m-9-9a9 9 0 009-9m-9 9h12"/>
                        </svg>
                    </div>
                    <div class="message-text">${this.formatMarkdown(text)}</div>
                </div>
                <div class="message-time">${this.getTimeString()}</div>
            `;
            this.container.appendChild(messageDiv);
            this.scrollToBottom();
        },

        addAIMessageHTML(htmlContent) {
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message ai-message';
            messageDiv.innerHTML = `
                <div class="message-content">
                    <div class="message-avatar">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M21 12a9 9 0 01-9 9m9-9a9 9 0 00-9-9m9 9H3m9 9a9 9 0 01-9-9m9 9c1.657 0 3-4.5 3-9s-1.343-9-3-9m-9 9a9 9 0 019 9m-9-9a9 9 0 009-9m-9 9h12"/>
                        </svg>
                    </div>
                    <div class="message-text">${htmlContent}</div>
                </div>
                <div class="message-time">${this.getTimeString()}</div>
            `;
            this.container.appendChild(messageDiv);
            this.scrollToBottom();
        },

        showLoading() {
            const loadingDiv = document.createElement('div');
            loadingDiv.className = 'message ai-message loading-message';
            loadingDiv.id = 'loading-indicator';
            loadingDiv.innerHTML = `
                <div class="message-content">
                    <div class="message-avatar">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M21 12a9 9 0 01-9 9m9-9a9 9 0 00-9-9m9 9H3m9 9a9 9 0 01-9-9m9 9c1.657 0 3-4.5 3-9s-1.343-9-3-9m-9 9a9 9 0 019 9m-9-9a9 9 0 009-9m-9 9h12"/>
                        </svg>
                    </div>
                    <div class="message-text">
                        <div class="typing-indicator">
                            <span></span><span></span><span></span>
                        </div>
                    </div>
                </div>
            `;
            this.container.appendChild(loadingDiv);
            this.scrollToBottom();
        },

        hideLoading() {
            const loading = document.getElementById('loading-indicator');
            if (loading) loading.remove();
        },

        scrollToBottom() {
            this.container.scrollTop = this.container.scrollHeight;
        },

        formatMarkdown(text) {
            return text
                .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                .replace(/\*(.*?)\*/g, '<em>$1</em>')
                .replace(/\n/g, '<br>');
        },

        escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        },

        getTimeString() {
            return new Date().toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
        }
    };

    // Chat Module
    const Chat = {
        currentMode: 'analytical',
        isProcessing: false,
        initialized: false, // Add flag to prevent duplicate initialization

        init() {
            if (this.initialized) return; // Prevent multiple initialization
            
            Messages.init('#chatMessages');
            this.setupEventListeners();
            
            // Check URL parameters first
            const urlParams = new URLSearchParams(window.location.search);
            const modeParam = urlParams.get('mode');
            
            if (modeParam === 'debate') {
                this.currentMode = 'debate';
            }

            // Clear messages container and add single welcome message
            const messages = document.getElementById('chatMessages');
            if (messages) {
                messages.innerHTML = '';
                this.addWelcomeMessage();
            }

            // Check for OCR result from sessionStorage (old single file format)
            const ocrResult = sessionStorage.getItem('ocrResult');
            if (ocrResult) {
                this.handleOCRResult(JSON.parse(ocrResult));
                sessionStorage.removeItem('ocrResult'); // Clear after using
            }

            // Check for OCR results from homepage (new multiple files format)
            const ocrResults = sessionStorage.getItem('ocrResults');
            if (ocrResults) {
                this.handleMultipleOCRResults(JSON.parse(ocrResults));
                sessionStorage.removeItem('ocrResults'); // Clear after using
            }

            // Update navigation active state
            document.querySelectorAll('.nav-item').forEach(nav => {
                const navMode = nav.getAttribute('data-mode');
                if (navMode === this.currentMode) {
                    nav.classList.add('active');
                } else {
                    nav.classList.remove('active');
                }
            });

            this.initialized = true; // Mark as initialized
        },

        handleOCRResult(ocrData) {
            // Clear welcome message
            const messages = document.getElementById('chatMessages');
            if (messages) {
                messages.innerHTML = '';
            }

            // Add user message showing the image was uploaded
            Messages.addUserMessage(`ðŸ“· Uploaded image: ${ocrData.filename}`);

            // Add AI analysis if available
            if (ocrData.aiAnalysis) {
                setTimeout(() => {
                    Messages.addAIMessage(ocrData.aiAnalysis);
                }, 500);
            }
        },

        handleMultipleOCRResults(ocrResults) {
            // Clear welcome message
            const messages = document.getElementById('chatMessages');
            if (messages) {
                messages.innerHTML = '';
            }

            // Add user message showing files were uploaded
            const fileNames = ocrResults.map(r => r.filename).join(', ');
            Messages.addUserMessage(`ðŸ“· Uploaded ${ocrResults.length} image(s): ${fileNames}`);

            // Optionally, you could ask the AI to analyze all the extracted text together
            const allText = ocrResults.map(r => `From ${r.filename}: ${r.extractedText}`).join('\n\n');
            const initialPrompt = sessionStorage.getItem('initialPrompt');
            
            if (initialPrompt) {
                setTimeout(async () => {
                    Messages.showLoading('Analyzing uploaded images with evidence gathering...');
                    try {
                        // Process each image with scraper-enhanced analysis
                        for (let i = 0; i < ocrResults.length; i++) {
                            const ocrData = ocrResults[i];
                            
                            // Create FormData for re-processing with scraper
                            // We'll use the extracted text to trigger scraper analysis
                            const analysisPrompt = `${initialPrompt}\n\nAnalyze this text extracted from ${ocrData.filename}:\n\n${ocrData.extractedText}`;
                            
                            const response = await fetch('/chat', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                    'X-API-Key': API_KEY
                                },
                                body: JSON.stringify({
                                    message: analysisPrompt,
                                    mode: this.currentMode,
                                    use_scraper: true  // Enable scraper for fact-checking
                                })
                            });

                            const data = await response.json();
                            
                            if (i === 0) {
                                Messages.hideLoading();
                            }
                            
                            if (data.analysis || data.result || data.answer) {
                                const aiMessage = data.analysis || data.result || data.answer;
                                Messages.addAIMessage(`**Analysis of "${ocrData.filename}" (${i + 1}/${ocrResults.length}):**\n\n${aiMessage}`);
                            }
                            
                            // Small delay between processing multiple files
                            if (i < ocrResults.length - 1) {
                                await new Promise(resolve => setTimeout(resolve, 1000));
                            }
                        }
                    } catch (error) {
                        Messages.hideLoading();
                        Messages.addAIMessage('âŒ Error analyzing images: ' + error.message);
                    }
                }, ocrResults.length * 300 + 500);
            }
        },

        switchMode(mode) {
            this.currentMode = mode;
            const chatTitle = document.getElementById('chatTitle');
            if (chatTitle) {
                chatTitle.textContent = mode === 'debate' ? 'Atlas Debate Mode' : 'Chat with Atlas';
            }
            
            // Update URL without reloading
            const url = new URL(window.location);
            if (mode === 'debate') {
                url.searchParams.set('mode', 'debate');
            } else {
                url.searchParams.delete('mode');
            }
            window.history.pushState({}, '', url);

            // Clear and show appropriate welcome message
            const messages = document.getElementById('chatMessages');
            if (messages) {
                messages.innerHTML = '';
                this.addWelcomeMessage();
            }
        },

        setupEventListeners() {
            const sendBtn = document.getElementById('sendBtn');
            const input = document.getElementById('messageInput');

            sendBtn?.addEventListener('click', () => this.handleSend());
            input?.addEventListener('keypress', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    this.handleSend();
                }
            });
        },

        async handleSend() {
            const input = document.getElementById('messageInput');
            const message = input.value.trim();
            const v2Enabled = document.getElementById('v2Toggle').checked;

            if (!message || this.isProcessing) return;

            this.isProcessing = true;
            input.value = '';
            
            Messages.addUserMessage(message);
            
            // Process all attached files before sending message
            if (Attachments.attachedFiles && Attachments.attachedFiles.length > 0) {
                Messages.addAIMessage(`ðŸ”„ Processing ${Attachments.attachedFiles.length} attached file(s)...`);
                
                for (let i = 0; i < Attachments.attachedFiles.length; i++) {
                    const file = Attachments.attachedFiles[i];
                    const fileName = file.name.toLowerCase();
                    
                    // Add separator for multiple files
                    if (Attachments.attachedFiles.length > 1) {
                        Messages.addAIMessage(`\n--- Processing file ${i + 1} of ${Attachments.attachedFiles.length}: ${file.name} ---\n`);
                    }
                    
                    // Check if it's an image or text file
                    const isImage = fileName.endsWith('.jpg') || fileName.endsWith('.jpeg') || fileName.endsWith('.png');
                    const isTextFile = fileName.endsWith('.md') || fileName.endsWith('.txt');
                    
                    if (isImage) {
                        await Attachments.processImageWithOCR(file);
                    } else if (isTextFile) {
                        await Attachments.processTextFile(file);
                    }
                    
                    // Small delay between files
                    if (i < Attachments.attachedFiles.length - 1) {
                        await new Promise(resolve => setTimeout(resolve, 500));
                    }
                }
                
                // Clear attached files after processing
                Attachments.attachedFiles = [];
                Messages.addAIMessage(`âœ… All files processed successfully!\n\n`);
                
                // Don't send additional message to chat endpoint - OCR already provided analysis
                this.isProcessing = false;
                return;
            }
            
            Messages.showLoading();

            // Add timeout for the request (90 seconds)
            const timeoutPromise = new Promise((_, reject) => 
                setTimeout(() => reject(new Error('Request timed out')), 90000)
            );

            try {
                console.log('Sending message:', message, 'V2 enabled:', v2Enabled);
                
                let response;
                if (v2Enabled && typeof ATLASv2 !== 'undefined') {
                    // Use v2.0 enhanced analysis
                    response = await Promise.race([
                        ATLASv2.analyzeWithV2(message, {
                            num_agents: 6,
                            enable_reversal: true,
                            reversal_rounds: 2
                        }),
                        timeoutPromise
                    ]);
                    
                    console.log('Received v2.0 response:', response);
                    Messages.hideLoading();
                    
                    if (response.success && response.data) {
                        // Use V2UI to render enhanced response
                        const v2Card = V2UI.createV2ResponseCard(response.data);
                        Messages.addAIMessageHTML(v2Card);
                    } else {
                        Messages.addAIMessage(response.error || 'v2.0 analysis failed');
                    }
                } else {
                    // Use standard v1.0 analysis
                    response = await Promise.race([
                        API.sendMessage(message, this.currentMode),
                        timeoutPromise
                    ]);
                    
                    console.log('Received response:', response);
                    Messages.hideLoading();
                    
                    const aiMessage = response.analysis || 
                                    response.result || 
                                    response.answer ||
                                    'No response received.';
                                    
                    Messages.addAIMessage(aiMessage);
                }
                
            } catch (error) {
                Messages.hideLoading();
                
                if (error.message === 'Request timed out') {
                    Messages.addAIMessage('â±ï¸ The request took too long. Please try a simpler question.');
                } else {
                    Messages.addAIMessage('âŒ Error: ' + error.message);
                }
                
                console.error('Chat error:', error);
            } finally {
                this.isProcessing = false;
            }
        },

        addWelcomeMessage() {
            const message = this.currentMode === 'debate' 
                ? "Welcome to **Debate Mode**! I'll analyze topics from multiple perspectives and provide evidence-based insights."
                : "Hello! I'm **Atlas**, your misinformation fighter. Ask me anything!";
            Messages.addAIMessage(message);
        }
    };

    // Attachments Module for Chat Page - MUST BE DEFINED BEFORE DOMContentLoaded
    const Attachments = {
        attachedFiles: [], // Store uploaded files here
        
        init() {
            console.log('ðŸ“Ž Initializing Attachments module...');
            
            const attachBtn = document.getElementById('attachBtn');
            const attachmentMenu = document.getElementById('attachmentMenu');
            const uploadFileBtn = document.getElementById('uploadFileBtn');
            const addLinkBtn = document.getElementById('addLinkBtn');
            const linkModal = document.getElementById('linkModal');
            const linkInput = document.getElementById('linkInput');
            const submitLinkBtn = document.getElementById('submitLinkBtn');
            const closeModalBtn = document.getElementById('closeModalBtn');

            console.log('Elements found:', {
                attachBtn: !!attachBtn,
                attachmentMenu: !!attachmentMenu,
                uploadFileBtn: !!uploadFileBtn
            });

            if (!attachBtn) {
                console.error('âŒ Attach button not found!');
                return;
            }
            
            if (!attachmentMenu) {
                console.error('âŒ Attachment menu not found!');
                return;
            }

            console.log('âœ… All required elements found, setting up event listeners...');

            // Add multiple event listeners for debugging
            attachBtn.addEventListener('mouseenter', function() {
                console.log('ðŸ–±ï¸ Mouse entered attach button');
            });

            attachBtn.addEventListener('mousedown', function() {
                console.log('ðŸ–±ï¸ Mouse down on attach button');
            });

            // Toggle attachment menu with direct addEventListener
            attachBtn.addEventListener('click', function(event) {
                console.log('ðŸ“Ž Attach button clicked!');
                event.stopPropagation();
                event.preventDefault();
                
                const isVisible = attachmentMenu.classList.contains('active');
                console.log('Menu currently visible:', isVisible);
                
                if (!isVisible) {
                    attachmentMenu.classList.add('active');
                    console.log('ðŸ“Ž Menu opened - adding active class');
                } else {
                    attachmentMenu.classList.remove('active');
                    console.log('ðŸ“Ž Menu closed - removing active class');
                }
            }, true); // Use capture phase

            // Close menu when clicking outside
            document.addEventListener('click', (event) => {
                if (!attachmentMenu) return;
                if (!attachmentMenu.classList.contains('active')) return;
                if (attachmentMenu.contains(event.target) || attachBtn.contains(event.target)) return;
                attachmentMenu.classList.remove('active');
                console.log('ðŸ“Ž Menu closed (outside click)');
            });

            // Handle file upload
            if (uploadFileBtn && attachmentMenu) {
                uploadFileBtn.addEventListener('click', async () => {
                    console.log('ðŸ“ Upload file button clicked');
                    attachmentMenu.classList.remove('active');
                    
                    const input = document.createElement('input');
                    input.type = 'file';
                    input.accept = '.jpg,.jpeg,.png,.md,.txt';
                    input.multiple = true; // Allow multiple files

                    const self = this; // Capture context
                    
                    input.onchange = async (e) => {
                        const files = Array.from(e.target.files);
                        if (files.length === 0) return;

                        console.log(`ðŸ“ ${files.length} file(s) selected`);

                        // Check file limit (maximum 5 files combined)
                        if (self.attachedFiles.length + files.length > 5) {
                            Messages.addAIMessage(`âŒ Maximum 5 files allowed. You have ${self.attachedFiles.length} files attached and trying to add ${files.length} more.`);
                            return;
                        }

                        // Validate each file
                        for (const file of files) {
                            console.log('ðŸ“ Validating file:', file.name, file.type, file.size);

                            // File size check (5MB limit)
                            if (file.size > 5 * 1024 * 1024) {
                                const fileSize = (file.size / (1024 * 1024)).toFixed(2);
                                Messages.addAIMessage(`âŒ File "${file.name}" exceeds maximum size.\n\nFile size: ${fileSize} MB\nMaximum allowed: 5 MB`);
                                continue;
                            }

                            // Format validation - only jpg, jpeg, png, md, txt
                            const allowedExtensions = ['.jpg', '.jpeg', '.png', '.md', '.txt'];
                            const fileName = file.name.toLowerCase();
                            const isValidFormat = allowedExtensions.some(ext => fileName.endsWith(ext));

                            if (!isValidFormat) {
                                Messages.addAIMessage(`âŒ Format not supported: "${file.name}"\n\nSupported formats: JPG, JPEG, PNG, MD, TXT`);
                                continue;
                            }

                            // Add file to attachedFiles array
                            self.attachedFiles.push(file);
                            console.log(`âœ… File "${file.name}" attached. Total files: ${self.attachedFiles.length}`);
                            
                            // Show preview for the file
                            self.showFilePreview(file);
                        }
                        
                        if (self.attachedFiles.length > 0) {
                            Messages.addAIMessage(`âœ… ${self.attachedFiles.length} file(s) ready. Type your message and click send to process.`);
                        }
                    };

                    input.click();
                });
            }

            // Handle link upload
            if (addLinkBtn && attachmentMenu && linkModal) {
                addLinkBtn.addEventListener('click', () => {
                    console.log('ðŸ”— Add link button clicked');
                    attachmentMenu.classList.remove('active');
                    linkModal.style.display = 'flex';
                    linkInput.value = '';
                    linkInput.focus();
                });
            }

            // Close link modal
            closeModalBtn?.addEventListener('click', () => {
                if (linkModal) linkModal.style.display = 'none';
            });

            // Submit link
            submitLinkBtn?.addEventListener('click', async () => {
                const url = linkInput.value.trim();
                if (!url) {
                    Messages.addAIMessage('âŒ Please enter a valid URL.');
                    return;
                }

                const self = this; // Capture context
                
                if (self.isValidUrl(url)) {
                    if (linkModal) linkModal.style.display = 'none';
                    Messages.addUserMessage(`ðŸ”— Link: ${url}`);
                    Messages.addAIMessage('ðŸ”— Link processing is not yet implemented.');
                } else {
                    Messages.addAIMessage('âŒ Invalid URL format.');
                }
            });

            console.log('âœ… Attachments module initialized');
        },

        showFilePreview(file) {
            const attachmentArea = document.getElementById('attachmentArea');
            if (!attachmentArea) return;

            const previewId = `preview-${Date.now()}-${Math.random()}`;
            const previewItem = document.createElement('div');
            previewItem.className = 'preview-item';
            previewItem.id = previewId;
            previewItem.style.cssText = 'display: inline-flex; align-items: center; margin: 5px; padding: 8px; background: rgba(255,255,255,0.1); border-radius: 8px; position: relative;';

            const isImage = file.type && file.type.startsWith('image/');
            const isText = file.name.toLowerCase().endsWith('.md') || file.name.toLowerCase().endsWith('.txt');

            // Create thumbnail
            const thumbnailDiv = document.createElement('div');
            thumbnailDiv.style.cssText = 'width: 60px; height: 60px; display: flex; align-items: center; justify-content: center; background: rgba(0,0,0,0.3); border-radius: 6px; overflow: hidden; margin-right: 10px;';

            if (isImage) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = document.createElement('img');
                    img.src = e.target.result;
                    img.style.cssText = 'width: 100%; height: 100%; object-fit: cover;';
                    thumbnailDiv.appendChild(img);
                };
                reader.readAsDataURL(file);
            } else if (isText) {
                thumbnailDiv.innerHTML = '<span style="font-size: 24px;">ðŸ“„</span>';
            } else {
                thumbnailDiv.innerHTML = '<span style="font-size: 24px;">ðŸ“Ž</span>';
            }

            // File info
            const infoDiv = document.createElement('div');
            infoDiv.style.cssText = 'flex: 1; min-width: 0;';
            const fileName = document.createElement('div');
            fileName.textContent = file.name;
            fileName.style.cssText = 'font-size: 14px; color: #fff; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;';
            const fileSize = document.createElement('div');
            fileSize.textContent = (file.size / 1024).toFixed(1) + ' KB';
            fileSize.style.cssText = 'font-size: 12px; color: rgba(255,255,255,0.6);';
            infoDiv.appendChild(fileName);
            infoDiv.appendChild(fileSize);

            // Remove button
            const removeBtn = document.createElement('button');
            removeBtn.innerHTML = 'Ã—';
            removeBtn.style.cssText = 'width: 24px; height: 24px; border-radius: 50%; border: none; background: rgba(255,255,255,0.2); color: #fff; cursor: pointer; font-size: 18px; margin-left: 10px;';
            removeBtn.onclick = () => {
                previewItem.remove();
                const index = this.attachedFiles.indexOf(file);
                if (index > -1) {
                    this.attachedFiles.splice(index, 1);
                }
                console.log(`ðŸ“Ž Removed "${file.name}". Total files: ${this.attachedFiles.length}`);
            };

            previewItem.appendChild(thumbnailDiv);
            previewItem.appendChild(infoDiv);
            previewItem.appendChild(removeBtn);
            attachmentArea.appendChild(previewItem);

            console.log(`ðŸ“¸ Preview added for "${file.name}"`);
        },

        isValidUrl(string) {
            try {
                new URL(string);
                return true;
            } catch (_) {
                return false;
            }
        },

        async processImageWithOCR(file) {
            console.log('ðŸ–¼ï¸ Starting OCR process for file:', file.name);
            
            try {
                // Create image preview - wait for it to load
                await new Promise((resolve) => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const imageUrl = e.target.result;
                        const fileSize = (file.size / 1024).toFixed(1) + ' KB';
                        const previewHtml = `
                            <div class="compact-preview-message">
                                <img src="${imageUrl}" alt="${file.name}" class="compact-preview-img">
                                <div class="compact-preview-info">
                                    <span class="compact-preview-name">${file.name}</span>
                                    <span class="compact-preview-type">
                                        Image â€¢ ${fileSize}
                                    </span>
                                </div>
                            </div>
                        `;
                        Messages.addUserMessageWithHTML(previewHtml);
                        resolve();
                    };
                    reader.readAsDataURL(file);
                });

                Messages.showLoading(`Processing "${file.name}" with OCR and gathering evidence...`);

                const formData = new FormData();
                formData.append('image', file);
                formData.append('analyze', 'true');  // Enable AI analysis
                formData.append('use_scraper', 'true');  // Enable scraper for evidence gathering

                console.log(`ðŸ“¤ Sending "${file.name}" to OCR endpoint with scraper enabled...`);
                
                const response = await fetch('http://127.0.0.1:5000/ocr_upload', {
                    method: 'POST',
                    body: formData
                });

                console.log(`ðŸ“¥ OCR Response for "${file.name}":`, response.status);

                if (!response.ok) {
                    throw new Error(`Server error: ${response.status}`);
                }

                const result = await response.json();
                console.log(`ðŸ“Š OCR Result for "${file.name}":`, result);

                Messages.hideLoading();

                if (result.success) {
                    const { ocr_result, ai_analysis, evidence_count, evidence_sources } = result;
                    
                    // Log the extracted text to console but don't show to user
                    console.log(`ðŸ“ "${file.name}" - Text Extracted (${ocr_result.confidence.toFixed(1)}% confidence)`);
                    console.log(`Text: ${ocr_result.text}`);
                    console.log(`Words found: ${ocr_result.word_count}`);
                    console.log(`Evidence sources: ${evidence_count}`);

                    // Show evidence sources if available
                    if (evidence_sources && evidence_sources.length > 0) {
                        let evidenceMessage = `**ðŸ“š Evidence gathered from ${evidence_count} source(s):**\n\n`;
                        evidence_sources.forEach((source, idx) => {
                            evidenceMessage += `${idx + 1}. **${source.title}**\n`;
                            evidenceMessage += `   ðŸ”— [${source.domain}](${source.url})\n`;
                            if (source.summary) {
                                evidenceMessage += `   ðŸ“„ ${source.summary.substring(0, 150)}...\n`;
                            }
                            evidenceMessage += `\n`;
                        });
                        Messages.addAIMessage(evidenceMessage);
                    }

                    // Show AI analysis to user with file context
                    if (ai_analysis) {
                        Messages.addAIMessage(`**ðŸ” Fact-Checked Analysis of "${file.name}":**\n\n${ai_analysis}`);
                    } else {
                        Messages.addAIMessage(`âœ… "${file.name}" processed successfully, but no analysis was generated.`);
                    }
                } else {
                    Messages.addAIMessage(`âŒ OCR Error for "${file.name}": ${result.error || 'Unknown error'}`);
                }

            } catch (error) {
                console.error('âŒ OCR Error:', error);
                Messages.hideLoading();
                Messages.addAIMessage(`âŒ Failed to process image: ${error.message}`);
            }
        },

        async processTextFile(file) {
            console.log('ðŸ“„ Starting text file processing for:', file.name);
            
            try {
                Messages.showLoading(`Reading "${file.name}"...`);
                
                // Read file content
                const textContent = await new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => resolve(e.target.result);
                    reader.onerror = () => reject(new Error('Failed to read file'));
                    reader.readAsText(file);
                });
                
                Messages.hideLoading();
                
                const wordCount = textContent.split(/\s+/).filter(w => w.length > 0).length;
                
                // Display file info
                Messages.addUserMessage(`ðŸ“„ ${file.name} (${wordCount} words)`);
                
                console.log(`âœ… Text extracted from ${file.name}: ${wordCount} words`);
                
            } catch (error) {
                console.error('âŒ Text file error:', error);
                Messages.hideLoading();
                Messages.addAIMessage(`âŒ Failed to process text file: ${error.message}`);
            }
        }
    };

    // Sidebar Module
    const Sidebar = {
        init() {
            const toggleBtn = document.getElementById('toggleBtn');
            const sidebar = document.getElementById('sidebar');

            toggleBtn?.addEventListener('click', () => {
                sidebar?.classList.toggle('collapsed');
            });
        }
    };

    // Initialize on DOM ready
    document.addEventListener('DOMContentLoaded', () => {
        console.log('Initializing Atlas Chat...');
        Chat.init();
        Sidebar.init();
        Attachments.init(); // Initialize attachment functionality
        
        // Initialize v2.0 toggle
        const v2Toggle = document.getElementById('v2Toggle');
        const v2Slider = document.getElementById('v2ToggleSlider');
        
        if (v2Toggle && v2Slider) {
            v2Toggle.addEventListener('change', function() {
                if (this.checked) {
                    v2Slider.style.transform = 'translateX(26px)';
                    v2Slider.parentElement.style.backgroundColor = '#3b82f6';
                    console.log('v2.0 Enhanced Analysis: ENABLED');
                } else {
                    v2Slider.style.transform = 'translateX(0)';
                    v2Slider.parentElement.style.backgroundColor = 'rgba(255,255,255,0.2)';
                    console.log('v2.0 Enhanced Analysis: DISABLED');
                }
            });
        }
    });
    </script>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const micBtn = document.getElementById('micBtn');
            const messageInput = document.getElementById('messageInput');

            if ('webkitSpeechRecognition' in window) {
                const recognition = new webkitSpeechRecognition();
                recognition.continuous = false;
                recognition.interimResults = false;
                recognition.lang = 'en-US';

                let isListening = false;

                micBtn.addEventListener('click', () => {
                    if (!isListening) {
                        recognition.start();
                        micBtn.classList.add('active');
                    } else {
                        recognition.stop();
                        micBtn.classList.remove('active');
                    }
                    isListening = !isListening;
                });

                recognition.onresult = (event) => {
                    const transcript = event.results[0][0].transcript;
                    messageInput.value = transcript;
                    micBtn.classList.remove('active');
                    isListening = false;
                };

                recognition.onerror = () => {
                    micBtn.classList.remove('active');
                    isListening = false;
                };

                recognition.onend = () => {
                    micBtn.classList.remove('active');
                    isListening = false;
                };
            } else {
                micBtn.style.display = 'none'; // Hide mic button if not supported
            }
        });
    </script>
    
    <!-- ATLAS v2.0 Integration -->
    <script src="{{ url_for('static', filename='js/atlas_v2.js') }}?v={{ range(1, 10000) | random }}"></script>
</body>
</html>
