<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Atlas Chat Interface</title>
    
    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700&family=Audiowide&display=swap" rel="stylesheet">
    
    <!-- CSS Modules with cache busting -->
    <link rel="stylesheet" href="{{ url_for('static', filename='css/base.css') }}?v={{ range(1, 10000) | random }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/layout.css') }}?v={{ range(1, 10000) | random }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/components.css') }}?v={{ range(1, 10000) | random }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/animations.css') }}?v={{ range(1, 10000) | random }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/atlas_v2.css') }}?v={{ range(1, 10000) | random }}">
    
    <style>
        /* Attachment area styling */
        .attachment-area {
            padding-bottom: 10px;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .preview-item {
            width: 90px;
            height: 90px;
            background-color: #2A2B32;
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 4px;
            overflow: hidden;
            position: relative;
        }

        .preview-item .preview-thumbnail {
            width: 100%;
            height: 100%;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #2A2B32;
        }

        .preview-item:hover::after {
            content: '';
            position: absolute;
            inset: 0;
            background: rgba(0,0,0,0.3);
            pointer-events: none;
        }

        .preview-item .preview-thumbnail img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .preview-item .preview-thumbnail svg {
            width: 32px;
            height: 32px;
            color: #ECECF1;
        }

        .file-type-indicator {
            position: absolute;
            bottom: 2px;
            right: 2px;
            background-color: rgba(52,53,65,0.9);
            padding: 1px 4px;
            border-radius: 3px;
            font-size: 9px;
            color: #ECECF1;
            border: 1px solid rgba(255,255,255,0.1);
            z-index: 1;
        }

        .preview-close-btn {
            position: absolute;
            top: 2px;
            right: 2px;
            width: 16px;
            height: 16px;
            border-radius: 3px;
            background: rgba(52,53,65,0.9);
            border: 1px solid rgba(255,255,255,0.1);
            color: #ECECF1;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 2;
            padding: 0;
        }

        .preview-close-btn:hover {
            background-color: rgba(32,33,35,0.9);
        }

        .preview-close-btn svg {
            width: 14px;
            height: 14px;
        }

        /* ChatGPT-style Compact Message Preview */
        .compact-preview-message {
            display: flex !important;
            align-items: center !important;
            gap: 10px !important;
            background: rgba(0,0,0,0.1) !important;
            padding: 8px !important;
            border-radius: 5px !important;
            border: 1px solid rgba(255,255,255,0.1) !important;
            width: fit-content !important;
            max-width: 300px !important;
            margin: 4px 0 !important;
        }

        .compact-preview-img {
            width: 70px !important;
            height: 70px !important;
            border-radius: 5px !important;
            object-fit: cover !important;
            flex-shrink: 0 !important;
            border: 1px solid rgba(255,255,255,0.1) !important;
        }

        .compact-preview-info {
            display: flex !important;
            flex-direction: column !important;
            gap: 4px !important;
            min-width: 0 !important;
            padding: 2px 0 !important;
        }

        .compact-preview-name {
            font-size: 13px !important;
            color: rgba(255,255,255,0.9) !important;
            white-space: nowrap !important;
            overflow: hidden !important;
            text-overflow: ellipsis !important;
            font-weight: 500 !important;
        }

        .compact-preview-type {
            font-size: 12px !important;
            color: rgba(255,255,255,0.5) !important;
            display: flex !important;
            align-items: center !important;
            gap: 4px !important;
        }

        .compact-preview-type::before {
            content: "ðŸ“„" !important;
            font-size: 12px !important;
        }

        .message-text .compact-preview-message {
            margin: 4px 0 !important;
        }

        /* CRITICAL: Force message layout - OVERRIDE EVERYTHING */
        .chat-messages {
            display: flex !important;
            flex-direction: column !important;
            gap: 0 !important;
            padding: 24px !important;
        }
        
        .message,
        .user-message,
        .ai-message,
        .bot {
            display: flex !important;
            flex-direction: column !important;
            margin-bottom: 24px !important;
            width: 100% !important;
            align-items: flex-start !important;
        }
        
        .user-message {
            align-items: flex-end !important;
        }
        
        .message-content {
            display: flex !important;
            flex-direction: row !important;
            align-items: flex-start !important;
            gap: 12px !important;
            max-width: 65% !important;
        }
        
        .user-message .message-content {
            flex-direction: row-reverse !important;
        }
        
        .message-avatar {
            width: 40px !important;
            height: 40px !important;
            min-width: 40px !important;
            border-radius: 50% !important;
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
            font-weight: 600 !important;
            font-size: 14px !important;
            flex-shrink: 0 !important;
        }
        
        .message-avatar svg {
            width: 20px !important;
            height: 20px !important;
            stroke: #00d9ff !important; /* Bright cyan color */
            filter: brightness(1.3) !important; /* Make it brighter */
        }
        
        .ai-message .message-avatar {
            background: linear-gradient(135deg, #1e3a8a 0%, #1e40af 100%) !important; /* Deep blue gradient */
            color: white !important;
        }
        
        .user-message .message-avatar {
            background: linear-gradient(135deg, #06b6d4 0%, #0891b2 100%) !important; /* Cyan gradient */
            color: white !important;
        }
        
        .message-text {
            padding: 12px 16px !important;
            border-radius: 16px !important;
            line-height: 1.6 !important;
            word-wrap: break-word !important;
            flex: 1 !important;
        }
        
        .user-message .message-text {
            background: linear-gradient(135deg, #3b82f6, #2563eb) !important;
            color: #ffffff !important;
            border-radius: 16px 16px 2px 16px !important;
        }
        
        .ai-message .message-text {
            background: rgba(30, 30, 30, 0.95) !important;
            color: #e5e7eb !important;
            border: 1px solid rgba(255, 255, 255, 0.08) !important;
            border-radius: 16px 16px 16px 2px !important;
        }
        
        .message-time {
            display: block !important;
            font-size: 10px !important;
            color: rgba(255, 255, 255, 0.4) !important;
            margin-top: 4px !important;
            padding-left: 52px !important;
        }
        
        .user-message .message-time {
            padding-left: 0 !important;
            padding-right: 52px !important;
            text-align: right !important;
        }
        
        /* Debate mode styling */
        .debate-message {
            margin: 12px 0;
            padding: 16px;
            border-radius: 8px;
            border-left: 4px solid;
        }
        
        .debate-message.proponent {
            background: rgba(59, 130, 246, 0.1);
            border-left-color: #3b82f6;
        }
        
        .debate-message.opponent {
            background: rgba(239, 68, 68, 0.1);
            border-left-color: #ef4444;
        }
        
        .debate-message.moderator {
            background: rgba(168, 85, 247, 0.1);
            border-left-color: #a855f7;
        }
        
        .debate-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 12px;
            font-size: 14px;
            font-weight: 600;
        }
        
        .debate-message.proponent .debate-header {
            color: #3b82f6;
        }
        
        .debate-message.opponent .debate-header {
            color: #ef4444;
        }
        
        .debate-message.moderator .debate-header {
            color: #a855f7;
        }
        
        .debate-icon {
            font-size: 18px;
        }
        
        .debate-content {
            color: #e5e7eb;
            line-height: 1.6;
        }
        
        .debate-content p {
            margin: 8px 0;
        }
    </style>
    <style>
        /* Message box outline and visibility for dark & light modes */
        .input-container {
            /* keep existing layout but ensure top border separation */
            border-top: 1px solid rgba(255,255,255,0.04);
            background: linear-gradient(180deg, rgba(0,0,0,0.22), rgba(0,0,0,0.18));
        }

        /* Wrapper keeps padding so the input stands out */
        .input-wrapper {
            display: flex;
            gap: 8px;
            align-items: center;
            padding: 14px 18px;
            max-width: 100%;
        }

        /* The text input itself: visible border, rounded, consistent padding */
        .message-input {
            flex: 1 1 auto;
            background: rgba(255,255,255,0.02);
            border: 1px solid rgba(255,255,255,0.08);
            color: rgba(255,255,255,0.95);
            padding: 12px 14px;
            border-radius: 12px;
            font-size: 14px;
            outline: none;
            transition: box-shadow 0.12s ease, border-color 0.12s ease, background-color 0.12s ease;
            box-shadow: 0 6px 18px rgba(0,0,0,0.55) inset;
        }

        .message-input:focus {
            border-color: #60a5fa; /* subtle blue focus */
            box-shadow: 0 6px 24px rgba(0,0,0,0.6) inset, 0 0 0 4px rgba(59,130,246,0.08);
        }

        /* Buttons beside input keep a consistent visual weight */
        .input-btn {
            background: rgba(255,255,255,0.03);
            border: 1px solid rgba(255,255,255,0.06);
            color: inherit;
        }

        /* Light mode overrides: ensure dark border/text on light bg */
        body.light-mode .input-container {
            border-top: 1px solid rgba(0,0,0,0.06);
            background: linear-gradient(180deg, #ffffff, #ffffff);
        }

        body.light-mode .message-input {
            background: #ffffff;
            border: 1px solid rgba(15,23,42,0.08);
            color: #0b1220;
            box-shadow: 0 6px 18px rgba(9,10,12,0.04) inset;
        }

        body.light-mode .message-input:focus {
            border-color: #2563eb;
            box-shadow: 0 6px 18px rgba(9,10,12,0.04) inset, 0 0 0 4px rgba(37,99,235,0.08);
        }
    </style>
    <style>
        /* Light mode adjustments */
        body.light-mode {
            background: #f8fafc;
            color: #0f172a;
        }
        body.light-mode .app-container,
        body.light-mode .chat-container,
        body.light-mode .sidebar {
            background: #ffffff;
            color: #0f172a;
        }
        body.light-mode .message-text {
            background: #f3f4f6 !important;
            color: #0f172a !important;
            border-color: rgba(0,0,0,0.06) !important;
        }
        body.light-mode .nav-item .nav-text { color: #0b1220 !important; }
    </style>
    <style>
        /* Light mode tweaks for header controls (v2 toggle) */
        body.light-mode .chat-header > div > span {
            color: rgba(15,23,42,0.8) !important; /* dark text for label */
        }

        /* Adjust toggle background and slider visibility in light mode */
        body.light-mode .chat-header label {
            background-color: rgba(15,23,42,0.06) !important;
        }

        body.light-mode #v2ToggleSlider {
            background-color: #ffffff !important; /* keep slider thumb visible */
        }

        /* When enabled, use accent color for slider track in light mode */
        body.light-mode #v2Toggle:checked + span {
            background-color: #3b82f6 !important;
        }
    </style>
    <style>
        /* Settings panel specific styles to ensure high contrast */
        #settingsPanel.modal-overlay {
            position: fixed;
            inset: 0;
            display: none;
            align-items: center;
            justify-content: center;
            background: rgba(0,0,0,0.55);
            z-index: 9999;
        }

        #settingsPanel .modal-content {
            background: rgba(18,18,20,0.96);
            color: #f8fafc;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 8px 30px rgba(0,0,0,0.6);
            width: 100%;
            max-width: 520px;
        }

        #settingsPanel h2 {
            margin: 0 0 10px 0;
            color: #f8fafc;
            font-size: 20px;
            text-align: center;
        }

        #settingsPanel .modal-content strong {
            color: #ffffff;
        }

        #settingsPanel .modal-content div {
            color: rgba(248,250,252,0.9);
        }

        #settingsPanel .input-btn {
            background: rgba(255,255,255,0.04);
            border: 1px solid rgba(255,255,255,0.08);
            color: #fff;
            cursor: pointer;
        }

        #settingsPanel .input-btn:hover {
            background: rgba(255,255,255,0.08);
        }

        #settingsPanel #deleteHistoryBtn {
            background: #ef4444;
            border: none;
            color: #fff;
        }

        /* Ensure Close button is visible */
        #settingsPanel #closeSettingsBtn {
            background: rgba(255,255,255,0.04);
            border: 1px solid rgba(255,255,255,0.08);
            color: #fff;
        }
    </style>
    <style>
        /* Sidebar icon visibility fixes: ensure SVG icons and logo are visible in dark and light modes */
        .sidebar .logo svg,
        .sidebar .nav-section svg,
        .sidebar .nav-item svg,
        .sidebar .toggle-btn svg {
            width: 28px;
            height: 28px;
            display: block;
            /* Force a visible stroke color regardless of inherited color */
            stroke: currentColor;
            color: #00d9ff; /* bright cyan accent for dark mode */
            fill: none;
            vertical-align: middle;
            opacity: 1;
        }

        .sidebar .logo-text {
            color: #00d9ff;
            font-weight: 700;
            margin-left: 8px;
        }

        /* Make nav-text readable and icons consistent */
        .sidebar .nav-text {
            color: rgba(255,255,255,0.95);
        }

        /* Light mode overrides: use dark colors so icons remain visible on light background */
        body.light-mode .sidebar .logo svg,
        body.light-mode .sidebar .nav-section svg,
        body.light-mode .sidebar .nav-item svg,
        body.light-mode .sidebar .toggle-btn svg {
            color: #0b1220; /* near-black for light background */
            stroke: currentColor;
        }

        body.light-mode .sidebar .logo-text,
        body.light-mode .sidebar .nav-text {
            color: #0b1220 !important;
        }

        /* Ensure sidebar icons render above background layers */
        .sidebar .logo,
        .sidebar .nav-item {
            z-index: 5;
        }

        /* Additional light-mode fixes for the sidebar toggle button (arrow visibility) */
        body.light-mode .sidebar .toggle-btn {
            background: rgba(255,255,255,0.95); /* keep button visible on light bg */
            border: 1px solid rgba(9,10,12,0.06);
            color: #0b1220 !important; /* ensure inherited currentColor is dark */
            box-shadow: 0 2px 6px rgba(9,10,12,0.04);
        }

        /* Make sure any SVG paths inside the toggle are dark and thicker for contrast */
        body.light-mode .sidebar .toggle-btn svg,
        body.light-mode .sidebar .toggle-btn svg path,
        body.light-mode .sidebar .toggle-btn svg line,
        body.light-mode .sidebar .toggle-btn svg polygon {
            color: #0b1220 !important;
            stroke: #0b1220 !important;
            stroke-width: 1.6 !important;
            fill: none !important;
            opacity: 1 !important;
        }

        /* Fallback: if toggle uses text/character arrow, ensure it's visible */
        body.light-mode .sidebar .toggle-btn::before,
        body.light-mode .sidebar .toggle-btn .arrow {
            color: #0b1220 !important;
            opacity: 1 !important;
        }
    </style>
</head>
<body>
    <!-- Starry Background -->
    <div class="starry-background">
        <div class="stars" id="stars"></div>
    </div>

    <!-- Main App -->
    <div class="app-container">
        <!-- Sidebar -->
        <aside class="sidebar" id="sidebar">
            <button class="toggle-btn" id="toggleBtn" aria-label="Toggle sidebar">
                <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M15 18l-6-6 6-6"/>
                </svg>
            </button>

            <div class="logo-section">
                <div class="logo">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M21 12a9 9 0 01-9 9m9-9a9 9 0 00-9-9m9 9H3m9 9a9 9 0 01-9-9m9 9c1.657 0 3-4.5 3-9s-1.343-9-3-9m-9 9a9 9 0 019 9m-9-9a9 9 0 009-9m-9 9h12"/>
                    </svg>
                </div>
                <span class="logo-text">Atlas</span>
            </div>

            <nav class="nav-section">
                <a href="/chat" class="nav-item active" data-mode="chat">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/>
                    </svg>
                    <span class="nav-text">Chat</span>
                </a>
                <a href="/chat?mode=debate" class="nav-item" data-mode="debate">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M13 2L3 14h9l-1 8 10-12h-9l1-8z"/>
                    </svg>
                    <span class="nav-text">Debate</span>
                </a>
                <div class="nav-item">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="9"></circle>
                        <polyline points="12 7 12 12 16 14"></polyline>
                    </svg>
                    <span class="nav-text">History</span>
                </div>
                <div class="nav-item" id="settingsBtn" role="button" tabindex="0">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="3"/>
                        <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06-.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"/>
                    </svg>
                    <span class="nav-text">Settings</span>
                </div>
            </nav>
        </aside>

        <!-- Chat Container -->
        <main class="chat-container">
            <div class="mobile-header" style="display: none;">
                <button class="menu-btn" id="mobileMenuBtn">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="3" y1="6" x2="21" y2="6"/>
                        <line x1="3" y1="12" x2="21" y2="12"/>
                        <line x1="3" y1="18" x2="21" y2="18"/>
                    </svg>
                </button>
                <span class="chat-title">Atlas Chat</span>
            </div>

            <header class="chat-header">
                <h1 class="chat-title" id="chatTitle">Chat with Atlas</h1>
                <div style="display: flex; align-items: center; gap: 12px;">
                    <span style="color: rgba(255,255,255,0.7); font-size: 13px; font-weight: 600;">v2.0 Enhanced Analysis</span>
                    <label style="position: relative; display: inline-block; width: 50px; height: 24px;">
                        <input type="checkbox" id="v2Toggle" style="opacity: 0; width: 0; height: 0;">
                        <span style="position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(255,255,255,0.2); transition: 0.3s; border-radius: 24px;">
                            <span id="v2ToggleSlider" style="position: absolute; content: ''; height: 18px; width: 18px; left: 3px; bottom: 3px; background-color: white; transition: 0.3s; border-radius: 50%;"></span>
                        </span>
                    </label>
                </div>
            </header>

            <div class="chat-messages" id="chatMessages">
                <!-- Remove all static content - keep div empty -->
            </div>

            <div class="input-container">
                <div id="attachmentArea" class="attachment-area"></div>
                <div class="input-toolbar">
                    <div class="toolbar-left">
                        <div class="attachment-container">
                            <button class="input-btn" id="attachBtn">
                                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <path d="M12 5v14m-7-7h14" />
                                </svg>
                            </button>
                            <div class="attachment-menu" id="attachmentMenu">
                                <button class="menu-item" id="uploadFileBtn">
                                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                                        <polyline points="17 8 12 3 7 8"/>
                                        <line x1="12" y1="3" x2="12" y2="15"/>
                                    </svg>
                                    <span>Upload File</span>
                                </button>
                                <button class="menu-item" id="addLinkBtn">
                                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.72"/>
                                        <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.72-1.72"/>
                                    </svg>
                                    <span>Add Link</span>
                                </button>
                            </div>
                        </div>
                    </div>
                    <div class="toolbar-right">
                        <span class="model-name send-text">SEND</span>
                        <button class="input-btn send-btn" id="sendBtn">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <line x1="22" y1="2" x2="11" y2="13"/>
                                <polygon points="22 2 15 22 11 13 2 9 22 2"/>
                            </svg>
                        </button>
                    </div>
                </div>
                <div class="input-wrapper">
                    <input type="text" class="message-input" id="messageInput" placeholder="Message Atlas..." />
                    <button class="input-btn mic-btn" id="micBtn" aria-label="Voice input">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/>
                            <path d="M19 10v2a7 7 0 0 1-14 0v-2"/>
                            <line x1="12" y1="19" x2="12" y2="23"/>
                            <line x1="8" y1="23" x2="16" y2="23"/>
                        </svg>
                    </button>
                </div>
            </div>
        </main>
    </div>

    <!-- Link Modal -->
    <div id="linkModal" class="modal-overlay">
        <div class="modal-content">
            <h2>Add a Link</h2>
            <input type="text" id="linkInput" placeholder="https://example.com">
            <div class="modal-buttons">
                <button id="closeModalBtn">Cancel</button>
                <button id="submitLinkBtn">Add Link</button>
            </div>
        </div>
    </div>

    <!-- Settings Panel -->
    <div id="settingsPanel" class="modal-overlay" style="display:none;">
        <div class="modal-content" style="max-width:420px;">
            <h2>Settings</h2>
            <div style="display:flex;flex-direction:column;gap:12px;">
                <div id="appearanceSection" style="display:flex;align-items:center;justify-content:space-between;">
                    <div>
                        <strong style="text-align: left;">Appearance</strong>
                        <div style="font-size:12px;color:rgba(255,255,255,0.7);">Toggle between dark and light mode</div>
                    </div>
                    <div>
                        <button id="appearanceToggle" class="input-btn" style="padding:8px 12px;border-radius:6px;">Change</button>
                    </div>
                </div>

                <div id="historySection" style="display:flex;align-items:center;justify-content:space-between;">
                    <div>
                        <strong style="text-align: left;">Delete History</strong>
                        <div style="font-size:12px;color:rgba(255,255,255,0.7);">Clear local chat messages and session data</div>
                    </div>
                    <div>
                        <button id="deleteHistoryBtn" class="input-btn" style="background:#ef4444;color:#fff;padding:8px 12px;border-radius:6px;">Delete</button>
                    </div>
                </div>

                <div style="display:flex;justify-content:flex-end;gap:8px;margin-top:6px;">
                    <button id="closeSettingsBtn" class="input-btn">Close</button>
                </div>
            </div>
        </div>
    </div>

    <!-- JavaScript Modules -->
    <script>
    // API Module with detailed logging
    const API = {
        baseURL: 'http://127.0.0.1:8000', // Backend server port

        async sendMessage(message, mode = 'analytical') {
            console.log('=== API Call ===');
            console.log('Message:', message);
            console.log('Mode:', mode);
            
            try {
                const response = await fetch(`${this.baseURL}/analyze_topic`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        topic: message, 
                        model: 'llama3',
                        mode: mode  // Send mode parameter to backend
                    })
                });
                
                console.log('Response status:', response.status);
                console.log('Response ok:', response.ok);
                
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`HTTP error! status: ${response.status}, body: ${errorText}`);
                }
                
                // Check if it's an SSE stream (debate mode)
                const contentType = response.headers.get('content-type');
                if (contentType && contentType.includes('text/event-stream')) {
                    // Return response for SSE streaming
                    return { isStream: true, response: response };
                }
                
                // Regular JSON response (analytical mode)
                const responseText = await response.text();
                console.log('Response text:', responseText);
                const data = JSON.parse(responseText);
                console.log('Parsed data:', data);
                return data;
                
            } catch (error) {
                console.error('=== API Error ===');
                console.error('Error details:', error);
                throw error;
            }
        }
    };

    // Messages Module
    const Messages = {
        container: null,

        init(containerSelector) {
            this.container = document.querySelector(containerSelector);
        },

        addUserMessage(text) {
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message user-message';
            messageDiv.innerHTML = `
                <div class="message-content">
                    <div class="message-avatar">You</div>
                    <div class="message-text">${this.escapeHtml(text)}</div>
                </div>
                <div class="message-time">${this.getTimeString()}</div>
            `;
            this.container.appendChild(messageDiv);
            this.scrollToBottom();
        },

        addUserMessageWithHTML(htmlContent) {
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message user-message';
            messageDiv.innerHTML = `
                <div class="message-content">
                    <div class="message-avatar">You</div>
                    <div class="message-text">${htmlContent}</div>
                </div>
                <div class="message-time">${this.getTimeString()}</div>
            `;
            this.container.appendChild(messageDiv);
            this.scrollToBottom();
        },

        addAIMessage(text) {
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message ai-message';
            messageDiv.innerHTML = `
                <div class="message-content">
                    <div class="message-avatar">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M21 12a9 9 0 01-9 9m9-9a9 9 0 00-9-9m9 9H3m9 9a9 9 0 01-9-9m9 9c1.657 0 3-4.5 3-9s-1.343-9-3-9m-9 9a9 9 0 019 9m-9-9a9 9 0 009-9m-9 9h12"/>
                        </svg>
                    </div>
                    <div class="message-text">${this.formatMarkdown(text)}</div>
                </div>
                <div class="message-time">${this.getTimeString()}</div>
            `;
            this.container.appendChild(messageDiv);
            this.scrollToBottom();
        },

        addAIMessageHTML(htmlContent) {
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message ai-message';
            messageDiv.innerHTML = `
                <div class="message-content">
                    <div class="message-avatar">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M21 12a9 9 0 01-9 9m9-9a9 9 0 00-9-9m9 9H3m9 9a9 9 0 01-9-9m9 9c1.657 0 3-4.5 3-9s-1.343-9-3-9m-9 9a9 9 0 019 9m-9-9a9 9 0 009-9m-9 9h12"/>
                        </svg>
                    </div>
                    <div class="message-text">${htmlContent}</div>
                </div>
                <div class="message-time">${this.getTimeString()}</div>
            `;
            this.container.appendChild(messageDiv);
            this.scrollToBottom();
        },

        showLoading() {
            const loadingDiv = document.createElement('div');
            loadingDiv.className = 'message ai-message loading-message';
            loadingDiv.id = 'loading-indicator';
            loadingDiv.innerHTML = `
                <div class="message-content">
                    <div class="message-avatar">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M21 12a9 9 0 01-9 9m9-9a9 9 0 00-9-9m9 9H3m9 9a9 9 0 01-9-9m9 9c1.657 0 3-4.5 3-9s-1.343-9-3-9m-9 9a9 9 0 019 9m-9-9a9 9 0 009-9m-9 9h12"/>
                        </svg>
                    </div>
                    <div class="message-text">
                        <div class="typing-indicator">
                            <span></span><span></span><span></span>
                        </div>
                    </div>
                </div>
            `;
            this.container.appendChild(loadingDiv);
            this.scrollToBottom();
        },

        hideLoading() {
            const loading = document.getElementById('loading-indicator');
            if (loading) loading.remove();
        },

        scrollToBottom() {
            this.container.scrollTop = this.container.scrollHeight;
        },

        formatMarkdown(text) {
            return text
                .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                .replace(/\*(.*?)\*/g, '<em>$1</em>')
                .replace(/\n/g, '<br>');
        },

        escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        },

        getTimeString() {
            return new Date().toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
        }
    };

    // Chat Module
    const Chat = {
        currentMode: 'analytical',
        isProcessing: false,
        initialized: false, // Add flag to prevent duplicate initialization

        init() {
            if (this.initialized) return; // Prevent multiple initialization
            
            Messages.init('#chatMessages');
            this.setupEventListeners();
            
            // Check URL parameters first
            const urlParams = new URLSearchParams(window.location.search);
            const modeParam = urlParams.get('mode');
            
            // Also check sessionStorage for chatMode (from homepage)
            const storedMode = sessionStorage.getItem('chatMode');
            
            if (modeParam === 'debate' || storedMode === 'debate') {
                this.currentMode = 'debate';
            } else if (storedMode === 'simplified') {
                this.currentMode = 'simplified';
            } else {
                this.currentMode = 'analytical';
            }
            
            // Clear the stored mode after using
            sessionStorage.removeItem('chatMode');
            
            // Update page title based on mode
            const chatTitle = document.getElementById('chatTitle');
            if (chatTitle) {
                if (this.currentMode === 'debate') {
                    chatTitle.textContent = 'ðŸŽ­ Atlas Debate Mode';
                    chatTitle.style.color = '#ef4444'; // Red accent for debate
                } else {
                    chatTitle.textContent = 'ðŸ’¬ Chat with Atlas';
                    chatTitle.style.color = '#60a5fa'; // Blue accent for chat
                }
            }

            // Clear messages container and add single welcome message
            const messages = document.getElementById('chatMessages');
            if (messages) {
                messages.innerHTML = '';
                this.addWelcomeMessage();
            }

            // Check for OCR result from sessionStorage (old single file format)
            const ocrResult = sessionStorage.getItem('ocrResult');
            if (ocrResult) {
                this.handleOCRResult(JSON.parse(ocrResult));
                sessionStorage.removeItem('ocrResult'); // Clear after using
            }

            // Check for OCR results from homepage (new multiple files format)
            const ocrResults = sessionStorage.getItem('ocrResults');
            if (ocrResults) {
                this.handleMultipleOCRResults(JSON.parse(ocrResults));
                sessionStorage.removeItem('ocrResults'); // Clear after using
            }

            // Update navigation active state
            document.querySelectorAll('.nav-item').forEach(nav => {
                const navMode = nav.getAttribute('data-mode');
                // Match debate mode, or match chat for analytical/simplified modes
                if (navMode === 'debate' && this.currentMode === 'debate') {
                    nav.classList.add('active');
                } else if (navMode === 'chat' && this.currentMode !== 'debate') {
                    nav.classList.add('active');
                } else {
                    nav.classList.remove('active');
                }
            });

            this.initialized = true; // Mark as initialized
        },

        handleOCRResult(ocrData) {
            // Clear welcome message
            const messages = document.getElementById('chatMessages');
            if (messages) {
                messages.innerHTML = '';
            }

            // Add user message showing the image was uploaded
            Messages.addUserMessage(`ðŸ“· Uploaded image: ${ocrData.filename}`);

            // Add AI analysis if available
            if (ocrData.aiAnalysis) {
                setTimeout(() => {
                    Messages.addAIMessage(ocrData.aiAnalysis);
                }, 500);
            }
        },

        handleMultipleOCRResults(ocrResults) {
            // Clear welcome message
            const messages = document.getElementById('chatMessages');
            if (messages) {
                messages.innerHTML = '';
            }

            // Add user message showing files were uploaded
            const fileNames = ocrResults.map(r => r.filename).join(', ');
            Messages.addUserMessage(`ðŸ“· Uploaded ${ocrResults.length} image(s): ${fileNames}`);

            // Optionally, you could ask the AI to analyze all the extracted text together
            const allText = ocrResults.map(r => `From ${r.filename}: ${r.extractedText}`).join('\n\n');
            const initialPrompt = sessionStorage.getItem('initialPrompt');
            
            if (initialPrompt) {
                setTimeout(async () => {
                    Messages.showLoading('Analyzing uploaded images with evidence gathering...');
                    try {
                        // Process each image with scraper-enhanced analysis
                        for (let i = 0; i < ocrResults.length; i++) {
                            const ocrData = ocrResults[i];
                            
                            // Create FormData for re-processing with scraper
                            // We'll use the extracted text to trigger scraper analysis
                            const analysisPrompt = `${initialPrompt}\n\nAnalyze this text extracted from ${ocrData.filename}:\n\n${ocrData.extractedText}`;
                            
                            const response = await fetch('/chat', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                    'X-API-Key': API_KEY
                                },
                                body: JSON.stringify({
                                    message: analysisPrompt,
                                    mode: this.currentMode,
                                    use_scraper: true  // Enable scraper for fact-checking
                                })
                            });

                            const data = await response.json();
                            
                            if (i === 0) {
                                Messages.hideLoading();
                            }
                            
                            if (data.analysis || data.result || data.answer) {
                                const aiMessage = data.analysis || data.result || data.answer;
                                Messages.addAIMessage(`**Analysis of "${ocrData.filename}" (${i + 1}/${ocrResults.length}):**\n\n${aiMessage}`);
                            }
                            
                            // Small delay between processing multiple files
                            if (i < ocrResults.length - 1) {
                                await new Promise(resolve => setTimeout(resolve, 1000));
                            }
                        }
                    } catch (error) {
                        Messages.hideLoading();
                        Messages.addAIMessage('âŒ Error analyzing images: ' + error.message);
                    }
                }, ocrResults.length * 300 + 500);
            }
        },

        switchMode(mode) {
            this.currentMode = mode;
            const chatTitle = document.getElementById('chatTitle');
            if (chatTitle) {
                if (mode === 'debate') {
                    chatTitle.textContent = 'ðŸŽ­ Atlas Debate Mode';
                    chatTitle.style.color = '#ef4444'; // Red accent for debate
                } else {
                    chatTitle.textContent = 'ðŸ’¬ Chat with Atlas';
                    chatTitle.style.color = '#60a5fa'; // Blue accent for chat
                }
            }
            
            // Update URL without reloading
            const url = new URL(window.location);
            if (mode === 'debate') {
                url.searchParams.set('mode', 'debate');
            } else {
                url.searchParams.delete('mode');
            }
            window.history.pushState({}, '', url);

            // Clear and show appropriate welcome message
            const messages = document.getElementById('chatMessages');
            if (messages) {
                messages.innerHTML = '';
                this.addWelcomeMessage();
            }
            
            console.log(`âœ… Switched to ${mode} mode`);
        },

        setupEventListeners() {
            const sendBtn = document.getElementById('sendBtn');
            const input = document.getElementById('messageInput');

            sendBtn?.addEventListener('click', () => this.handleSend());
            input?.addEventListener('keypress', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    this.handleSend();
                }
            });
        },

        async handleSend() {
            const input = document.getElementById('messageInput');
            const message = input.value.trim();
            const v2Enabled = document.getElementById('v2Toggle').checked;

            if (!message || this.isProcessing) return;

            this.isProcessing = true;
            input.value = '';
            
            Messages.addUserMessage(message);
            
            // Process all attached files before sending message
            if (Attachments.attachedFiles && Attachments.attachedFiles.length > 0) {
                Messages.addAIMessage(`ðŸ”„ Processing ${Attachments.attachedFiles.length} attached file(s)...`);
                
                for (let i = 0; i < Attachments.attachedFiles.length; i++) {
                    const file = Attachments.attachedFiles[i];
                    const fileName = file.name.toLowerCase();
                    
                    // Add separator for multiple files
                    if (Attachments.attachedFiles.length > 1) {
                        Messages.addAIMessage(`\n--- Processing file ${i + 1} of ${Attachments.attachedFiles.length}: ${file.name} ---\n`);
                    }
                    
                    // Check if it's an image or text file
                    const isImage = fileName.endsWith('.jpg') || fileName.endsWith('.jpeg') || fileName.endsWith('.png');
                    const isTextFile = fileName.endsWith('.md') || fileName.endsWith('.txt');
                    
                    if (isImage) {
                        await Attachments.processImageWithOCR(file);
                    } else if (isTextFile) {
                        await Attachments.processTextFile(file);
                    }
                    
                    // Small delay between files
                    if (i < Attachments.attachedFiles.length - 1) {
                        await new Promise(resolve => setTimeout(resolve, 500));
                    }
                }
                
                // Clear attached files after processing
                Attachments.attachedFiles = [];
                Messages.addAIMessage(`âœ… All files processed successfully!\n\n`);
                
                // Don't send additional message to chat endpoint - OCR already provided analysis
                this.isProcessing = false;
                return;
            }
            
            Messages.showLoading();

            // Add timeout for the request (90 seconds)
            const timeoutPromise = new Promise((_, reject) => 
                setTimeout(() => reject(new Error('Request timed out')), 90000)
            );

            try {
                console.log('Sending message:', message, 'Mode:', this.currentMode, 'V2 enabled:', v2Enabled);
                
                let response;
                
                // DEBATE MODE: Always use streaming debate, ignore v2 toggle
                if (this.currentMode === 'debate') {
                    console.log('ðŸŽ­ Running debate mode...');
                    response = await Promise.race([
                        API.sendMessage(message, 'debate'),
                        timeoutPromise
                    ]);
                    
                    Messages.hideLoading();
                    
                    // Should be SSE stream
                    if (response && response.isStream) {
                        await this.handleDebateStream(response.response, message);
                    } else {
                        Messages.addAIMessage('Error: Expected debate stream but got regular response.');
                    }
                }
                // CHAT MODE: Use v2.0 if enabled, otherwise standard chat
                else {
                    if (v2Enabled && typeof ATLASv2 !== 'undefined') {
                        console.log('ðŸ’Ž Using v2.0 enhanced analysis...');
                        // Use v2.0 enhanced analysis
                        response = await Promise.race([
                            ATLASv2.analyzeWithV2(message, {
                                num_agents: 6,
                                enable_reversal: true,
                                reversal_rounds: 2
                            }),
                            timeoutPromise
                        ]);
                        
                        console.log('Received v2.0 response:', response);
                        Messages.hideLoading();
                        
                        if (response.success && response.data) {
                            // Use V2UI to render enhanced response
                            const v2Card = V2UI.createV2ResponseCard(response.data);
                            Messages.addAIMessageHTML(v2Card);
                        } else {
                            Messages.addAIMessage(response.error || 'v2.0 analysis failed');
                        }
                    } else {
                        console.log('ðŸ’¬ Using standard chat analysis...');
                        // Use standard v1.0 analysis
                        response = await Promise.race([
                            API.sendMessage(message, 'analytical'),
                            timeoutPromise
                        ]);
                        
                        console.log('Received response:', response);
                        Messages.hideLoading();
                        
                        // Regular chat response
                        const aiMessage = response.analysis || 
                                        response.result || 
                                        response.answer ||
                                        'No response received.';
                                        
                        Messages.addAIMessage(aiMessage);
                    }
                }
                
            } catch (error) {
                Messages.hideLoading();
                
                if (error.message === 'Request timed out') {
                    Messages.addAIMessage('â±ï¸ The request took too long. Please try a simpler question.');
                } else {
                    Messages.addAIMessage('âŒ Error: ' + error.message);
                }
                
                console.error('Chat error:', error);
            } finally {
                this.isProcessing = false;
            }
        },

        async handleDebateStream(response, originalTopic) {
            console.log('ðŸ“¡ Handling debate stream...');
            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            
            let currentRole = null;
            let currentContent = '';
            let messageDiv = null;
            
            try {
                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;
                    
                    const chunk = decoder.decode(value, { stream: true });
                    const lines = chunk.split('\n');
                    
                    for (const line of lines) {
                        if (!line.trim() || line.startsWith(':')) continue;
                        
                        if (line.startsWith('data: ')) {
                            const data = line.substring(6).trim();
                            
                            if (data === '[DONE]') {
                                // Flush any remaining content
                                if (currentContent && messageDiv) {
                                    messageDiv.innerHTML = this.formatDebateContent(currentContent, currentRole);
                                }
                                console.log('âœ… Debate stream complete');
                                return;
                            }
                            
                            try {
                                const json = JSON.parse(data);
                                
                                // Check for role change
                                if (json.role && json.role !== currentRole) {
                                    // Flush previous content
                                    if (currentContent && messageDiv) {
                                        messageDiv.innerHTML = this.formatDebateContent(currentContent, currentRole);
                                    }
                                    
                                    // Start new message
                                    currentRole = json.role;
                                    currentContent = '';
                                    messageDiv = this.createDebateMessage(currentRole);
                                }
                                
                                // Append content (backend sends "text" not "content")
                                if (json.text || json.content) {
                                    currentContent += (json.text || json.content);
                                    if (messageDiv) {
                                        messageDiv.innerHTML = this.formatDebateContent(currentContent, currentRole);
                                    }
                                }
                                
                            } catch (e) {
                                console.error('Error parsing SSE data:', e, data);
                            }
                        }
                    }
                }
            } catch (error) {
                console.error('Error in debate stream:', error);
                Messages.addAIMessage('âŒ Error streaming debate: ' + error.message);
            }
        },

        createDebateMessage(role) {
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message ai-message';
            Messages.container.appendChild(messageDiv);
            Messages.container.scrollTop = Messages.container.scrollHeight;
            return messageDiv;
        },

        formatDebateContent(content, role) {
            let icon, label, colorClass;
            
            if (role === 'proponent') {
                icon = 'ðŸ”µ';
                label = 'PROPONENT';
                colorClass = 'proponent';
            } else if (role === 'opponent') {
                icon = 'ðŸ”´';
                label = 'OPPONENT';
                colorClass = 'opponent';
            } else if (role === 'moderator') {
                icon = 'ðŸŽ™ï¸';
                label = 'MODERATOR';
                colorClass = 'moderator';
            } else {
                icon = 'ðŸ’¬';
                label = role.toUpperCase();
                colorClass = 'default';
            }
            
            return `
                <div class="debate-message ${colorClass}">
                    <div class="debate-header">
                        <span class="debate-icon">${icon}</span>
                        <strong>${label}</strong>
                    </div>
                    <div class="debate-content">${this.markdownToHtml(content)}</div>
                </div>
            `;
        },

        markdownToHtml(text) {
            // Basic markdown conversion
            return text
                .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                .replace(/\*(.*?)\*/g, '<em>$1</em>')
                .replace(/\n\n/g, '</p><p>')
                .replace(/\n/g, '<br>');
        },

        addWelcomeMessage() {
            let message;
            if (this.currentMode === 'debate') {
                message = "ðŸŽ­ **Welcome to Debate Mode!**\n\nI'll analyze your topic by presenting arguments from both sides:\nâ€¢ ðŸ”µ **Proponent** - Arguments in favor\nâ€¢ ðŸ”´ **Opponent** - Counter-arguments\nâ€¢ ðŸŽ™ï¸ **Moderator** - Synthesis and balance\n\nAsk me to debate any topic!";
            } else {
                message = "ðŸ‘‹ Hello! I'm **Atlas**, your misinformation fighter.\n\nðŸ’¬ **Chat Mode**: I'll provide clear, factual analysis of your questions.\n\nðŸ’¡ **Tip**: Toggle v2.0 for enhanced multi-perspective analysis, or switch to Debate mode for structured debates!";
            }
            Messages.addAIMessage(message);
        }
    };

    // Attachments Module for Chat Page - MUST BE DEFINED BEFORE DOMContentLoaded
    const Attachments = {
        attachedFiles: [], // Store uploaded files here
        
        init() {
            console.log('ðŸ“Ž Initializing Attachments module...');
            
            const attachBtn = document.getElementById('attachBtn');
            const attachmentMenu = document.getElementById('attachmentMenu');
            const uploadFileBtn = document.getElementById('uploadFileBtn');
            const addLinkBtn = document.getElementById('addLinkBtn');
            const linkModal = document.getElementById('linkModal');
            const linkInput = document.getElementById('linkInput');
            const submitLinkBtn = document.getElementById('submitLinkBtn');
            const closeModalBtn = document.getElementById('closeModalBtn');

            console.log('Elements found:', {
                attachBtn: !!attachBtn,
                attachmentMenu: !!attachmentMenu,
                uploadFileBtn: !!uploadFileBtn
            });

            if (!attachBtn) {
                console.error('âŒ Attach button not found!');
                return;
            }
            
            if (!attachmentMenu) {
                console.error('âŒ Attachment menu not found!');
                return;
            }

            console.log('âœ… All required elements found, setting up event listeners...');

            // Add multiple event listeners for debugging
            attachBtn.addEventListener('mouseenter', function() {
                console.log('ðŸ–±ï¸ Mouse entered attach button');
            });

            attachBtn.addEventListener('mousedown', function() {
                console.log('ðŸ–±ï¸ Mouse down on attach button');
            });

            // Toggle attachment menu with direct addEventListener
            attachBtn.addEventListener('click', function(event) {
                console.log('ðŸ“Ž Attach button clicked!');
                event.stopPropagation();
                event.preventDefault();
                
                const isVisible = attachmentMenu.classList.contains('active');
                console.log('Menu currently visible:', isVisible);
                
                if (!isVisible) {
                    attachmentMenu.classList.add('active');
                    console.log('ðŸ“Ž Menu opened - adding active class');
                } else {
                    attachmentMenu.classList.remove('active');
                    console.log('ðŸ“Ž Menu closed - removing active class');
                }
            }, true); // Use capture phase

            // Close menu when clicking outside
            document.addEventListener('click', (event) => {
                if (!attachmentMenu) return;
                if (!attachmentMenu.classList.contains('active')) return;
                if (attachmentMenu.contains(event.target) || attachBtn.contains(event.target)) return;
                attachmentMenu.classList.remove('active');
                console.log('ðŸ“Ž Menu closed (outside click)');
            });

            // Handle file upload
            if (uploadFileBtn && attachmentMenu) {
                uploadFileBtn.addEventListener('click', async () => {
                    console.log('ðŸ“ Upload file button clicked');
                    attachmentMenu.classList.remove('active');
                    
                    const input = document.createElement('input');
                    input.type = 'file';
                    input.accept = '.jpg,.jpeg,.png,.md,.txt';
                    input.multiple = true; // Allow multiple files

                    const self = this; // Capture context
                    
                    input.onchange = async (e) => {
                        const files = Array.from(e.target.files);
                        if (files.length === 0) return;

                        console.log(`ðŸ“ ${files.length} file(s) selected`);

                        // Check file limit (maximum 5 files combined)
                        if (self.attachedFiles.length + files.length > 5) {
                            Messages.addAIMessage(`âŒ Maximum 5 files allowed. You have ${self.attachedFiles.length} files attached and trying to add ${files.length} more.`);
                            return;
                        }

                        // Validate each file
                        for (const file of files) {
                            console.log('ðŸ“ Validating file:', file.name, file.type, file.size);

                            // File size check (5MB limit)
                            if (file.size > 5 * 1024 * 1024) {
                                const fileSize = (file.size / (1024 * 1024)).toFixed(2);
                                Messages.addAIMessage(`âŒ File "${file.name}" exceeds maximum size.\n\nFile size: ${fileSize} MB\nMaximum allowed: 5 MB`);
                                continue;
                            }

                            // Format validation - only jpg, jpeg, png, md, txt
                            const allowedExtensions = ['.jpg', '.jpeg', '.png', '.md', '.txt'];
                            const fileName = file.name.toLowerCase();
                            const isValidFormat = allowedExtensions.some(ext => fileName.endsWith(ext));

                            if (!isValidFormat) {
                                Messages.addAIMessage(`âŒ Format not supported: "${file.name}"\n\nSupported formats: JPG, JPEG, PNG, MD, TXT`);
                                continue;
                            }

                            // Add file to attachedFiles array
                            self.attachedFiles.push(file);
                            console.log(`âœ… File "${file.name}" attached. Total files: ${self.attachedFiles.length}`);
                            
                            // Show preview for the file
                            self.showFilePreview(file);
                        }
                        
                        if (self.attachedFiles.length > 0) {
                            Messages.addAIMessage(`âœ… ${self.attachedFiles.length} file(s) ready. Type your message and click send to process.`);
                        }
                    };

                    input.click();
                });
            }

            // Handle link upload
            if (addLinkBtn && attachmentMenu && linkModal) {
                addLinkBtn.addEventListener('click', () => {
                    console.log('ðŸ”— Add link button clicked');
                    attachmentMenu.classList.remove('active');
                    linkModal.style.display = 'flex';
                    linkInput.value = '';
                    linkInput.focus();
                });
            }

            // Close link modal
            closeModalBtn?.addEventListener('click', () => {
                if (linkModal) linkModal.style.display = 'none';
            });

            // Submit link
            submitLinkBtn?.addEventListener('click', async () => {
                const url = linkInput.value.trim();
                if (!url) {
                    Messages.addAIMessage('âŒ Please enter a valid URL.');
                    return;
                }

                const self = this; // Capture context
                
                if (self.isValidUrl(url)) {
                    if (linkModal) linkModal.style.display = 'none';
                    Messages.addUserMessage(`ðŸ”— Link: ${url}`);
                    Messages.addAIMessage('ðŸ”— Link processing is not yet implemented.');
                } else {
                    Messages.addAIMessage('âŒ Invalid URL format.');
                }
            });

            console.log('âœ… Attachments module initialized');
        },

        showFilePreview(file) {
            const attachmentArea = document.getElementById('attachmentArea');
            if (!attachmentArea) return;

            const previewId = `preview-${Date.now()}-${Math.random()}`;
            const previewItem = document.createElement('div');
            previewItem.className = 'preview-item';
            previewItem.id = previewId;
            previewItem.style.cssText = 'display: inline-flex; align-items: center; margin: 5px; padding: 8px; background: rgba(255,255,255,0.1); border-radius: 8px; position: relative;';

            const isImage = file.type && file.type.startsWith('image/');
            const isText = file.name.toLowerCase().endsWith('.md') || file.name.toLowerCase().endsWith('.txt');

            // Create thumbnail
            const thumbnailDiv = document.createElement('div');
            thumbnailDiv.style.cssText = 'width: 60px; height: 60px; display: flex; align-items: center; justify-content: center; background: rgba(0,0,0,0.3); border-radius: 6px; overflow: hidden; margin-right: 10px;';

            if (isImage) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = document.createElement('img');
                    img.src = e.target.result;
                    img.style.cssText = 'width: 100%; height: 100%; object-fit: cover;';
                    thumbnailDiv.appendChild(img);
                };
                reader.readAsDataURL(file);
            } else if (isText) {
                thumbnailDiv.innerHTML = '<span style="font-size: 24px;">ðŸ“„</span>';
            } else {
                thumbnailDiv.innerHTML = '<span style="font-size: 24px;">ðŸ“Ž</span>';
            }

            // File info
            const infoDiv = document.createElement('div');
            infoDiv.style.cssText = 'flex: 1; min-width: 0;';
            const fileName = document.createElement('div');
            fileName.textContent = file.name;
            fileName.style.cssText = 'font-size: 14px; color: #fff; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;';
            const fileSize = document.createElement('div');
            fileSize.textContent = (file.size / 1024).toFixed(1) + ' KB';
            fileSize.style.cssText = 'font-size: 12px; color: rgba(255,255,255,0.6);';
            infoDiv.appendChild(fileName);
            infoDiv.appendChild(fileSize);

            // Remove button
            const removeBtn = document.createElement('button');
            removeBtn.innerHTML = 'Ã—';
            removeBtn.style.cssText = 'width: 24px; height: 24px; border-radius: 50%; border: none; background: rgba(255,255,255,0.2); color: #fff; cursor: pointer; font-size: 18px; margin-left: 10px;';
            removeBtn.onclick = () => {
                previewItem.remove();
                const index = this.attachedFiles.indexOf(file);
                if (index > -1) {
                    this.attachedFiles.splice(index, 1);
                }
                console.log(`ðŸ“Ž Removed "${file.name}". Total files: ${this.attachedFiles.length}`);
            };

            previewItem.appendChild(thumbnailDiv);
            previewItem.appendChild(infoDiv);
            previewItem.appendChild(removeBtn);
            attachmentArea.appendChild(previewItem);

            console.log(`ðŸ“¸ Preview added for "${file.name}"`);
        },

        isValidUrl(string) {
            try {
                new URL(string);
                return true;
            } catch (_) {
                return false;
            }
        },

        async processImageWithOCR(file) {
            console.log('ðŸ–¼ï¸ Starting OCR process for file:', file.name);
            
            try {
                // Create image preview - wait for it to load
                await new Promise((resolve) => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const imageUrl = e.target.result;
                        const fileSize = (file.size / 1024).toFixed(1) + ' KB';
                        const previewHtml = `
                            <div class="compact-preview-message">
                                <img src="${imageUrl}" alt="${file.name}" class="compact-preview-img">
                                <div class="compact-preview-info">
                                    <span class="compact-preview-name">${file.name}</span>
                                    <span class="compact-preview-type">
                                        Image â€¢ ${fileSize}
                                    </span>
                                </div>
                            </div>
                        `;
                        Messages.addUserMessageWithHTML(previewHtml);
                        resolve();
                    };
                    reader.readAsDataURL(file);
                });

                Messages.showLoading(`Processing "${file.name}" with OCR and gathering evidence...`);

                const formData = new FormData();
                formData.append('image', file);
                formData.append('analyze', 'true');  // Enable AI analysis
                formData.append('use_scraper', 'true');  // Enable scraper for evidence gathering

                console.log(`ðŸ“¤ Sending "${file.name}" to OCR endpoint with scraper enabled...`);
                
                const response = await fetch('http://127.0.0.1:5000/ocr_upload', {
                    method: 'POST',
                    body: formData
                });

                console.log(`ðŸ“¥ OCR Response for "${file.name}":`, response.status);

                if (!response.ok) {
                    throw new Error(`Server error: ${response.status}`);
                }

                const result = await response.json();
                console.log(`ðŸ“Š OCR Result for "${file.name}":`, result);

                Messages.hideLoading();

                if (result.success) {
                    const { ocr_result, ai_analysis, evidence_count, evidence_sources } = result;
                    
                    // Log the extracted text to console but don't show to user
                    console.log(`ðŸ“ "${file.name}" - Text Extracted (${ocr_result.confidence.toFixed(1)}% confidence)`);
                    console.log(`Text: ${ocr_result.text}`);
                    console.log(`Words found: ${ocr_result.word_count}`);
                    console.log(`Evidence sources: ${evidence_count}`);

                    // Show evidence sources if available
                    if (evidence_sources && evidence_sources.length > 0) {
                        let evidenceMessage = `**ðŸ“š Evidence gathered from ${evidence_count} source(s):**\n\n`;
                        evidence_sources.forEach((source, idx) => {
                            evidenceMessage += `${idx + 1}. **${source.title}**\n`;
                            evidenceMessage += `   ðŸ”— [${source.domain}](${source.url})\n`;
                            if (source.summary) {
                                evidenceMessage += `   ðŸ“„ ${source.summary.substring(0, 150)}...\n`;
                            }
                            evidenceMessage += `\n`;
                        });
                        Messages.addAIMessage(evidenceMessage);
                    }

                    // Show AI analysis to user with file context
                    if (ai_analysis) {
                        Messages.addAIMessage(`**ðŸ” Fact-Checked Analysis of "${file.name}":**\n\n${ai_analysis}`);
                    } else {
                        Messages.addAIMessage(`âœ… "${file.name}" processed successfully, but no analysis was generated.`);
                    }
                } else {
                    Messages.addAIMessage(`âŒ OCR Error for "${file.name}": ${result.error || 'Unknown error'}`);
                }

            } catch (error) {
                console.error('âŒ OCR Error:', error);
                Messages.hideLoading();
                Messages.addAIMessage(`âŒ Failed to process image: ${error.message}`);
            }
        },

        async processTextFile(file) {
            console.log('ðŸ“„ Starting text file processing for:', file.name);
            
            try {
                Messages.showLoading(`Reading "${file.name}"...`);
                
                // Read file content
                const textContent = await new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => resolve(e.target.result);
                    reader.onerror = () => reject(new Error('Failed to read file'));
                    reader.readAsText(file);
                });
                
                Messages.hideLoading();
                
                const wordCount = textContent.split(/\s+/).filter(w => w.length > 0).length;
                
                // Display file info
                Messages.addUserMessage(`ðŸ“„ ${file.name} (${wordCount} words)`);
                
                console.log(`âœ… Text extracted from ${file.name}: ${wordCount} words`);
                
            } catch (error) {
                console.error('âŒ Text file error:', error);
                Messages.hideLoading();
                Messages.addAIMessage(`âŒ Failed to process text file: ${error.message}`);
            }
        }
    };

    // Sidebar Module
    const Sidebar = {
        init() {
            const toggleBtn = document.getElementById('toggleBtn');
            const sidebar = document.getElementById('sidebar');

            toggleBtn?.addEventListener('click', () => {
                sidebar?.classList.toggle('collapsed');
            });
        }
    };

    // Initialize on DOM ready
    document.addEventListener('DOMContentLoaded', () => {
        console.log('Initializing Atlas Chat...');
        Chat.init();
        Sidebar.init();
        Attachments.init(); // Initialize attachment functionality
        
        // Initialize v2.0 toggle
        const v2Toggle = document.getElementById('v2Toggle');
        const v2Slider = document.getElementById('v2ToggleSlider');
        
        if (v2Toggle && v2Slider) {
            v2Toggle.addEventListener('change', function() {
                if (this.checked) {
                    v2Slider.style.transform = 'translateX(26px)';
                    v2Slider.parentElement.style.backgroundColor = '#3b82f6';
                    console.log('v2.0 Enhanced Analysis: ENABLED');
                } else {
                    v2Slider.style.transform = 'translateX(0)';
                    v2Slider.parentElement.style.backgroundColor = 'rgba(255,255,255,0.2)';
                    console.log('v2.0 Enhanced Analysis: DISABLED');
                }
            });
        }
    });
    </script>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const micBtn = document.getElementById('micBtn');
            const messageInput = document.getElementById('messageInput');

            if ('webkitSpeechRecognition' in window) {
                const recognition = new webkitSpeechRecognition();
                recognition.continuous = false;
                recognition.interimResults = false;
                recognition.lang = 'en-US';

                let isListening = false;

                micBtn.addEventListener('click', () => {
                    if (!isListening) {
                        recognition.start();
                        micBtn.classList.add('active');
                    } else {
                        recognition.stop();
                        micBtn.classList.remove('active');
                    }
                    isListening = !isListening;
                });

                recognition.onresult = (event) => {
                    const transcript = event.results[0][0].transcript;
                    messageInput.value = transcript;
                    micBtn.classList.remove('active');
                    isListening = false;
                };

                recognition.onerror = () => {
                    micBtn.classList.remove('active');
                    isListening = false;
                };

                recognition.onend = () => {
                    micBtn.classList.remove('active');
                    isListening = false;
                };
            } else {
                micBtn.style.display = 'none'; // Hide mic button if not supported
            }
        });
    </script>
    
    <!-- Settings JS -->
    <script>
        (function() {
            // Elements
            const settingsBtn = document.getElementById('settingsBtn');
            const settingsPanel = document.getElementById('settingsPanel');
            const closeSettingsBtn = document.getElementById('closeSettingsBtn');
            const appearanceToggle = document.getElementById('appearanceToggle');
            const deleteHistoryBtn = document.getElementById('deleteHistoryBtn');

            function openSettings() {
                if (settingsPanel) settingsPanel.style.display = 'flex';
            }

            function closeSettings() {
                if (settingsPanel) settingsPanel.style.display = 'none';
            }

            function applyAppearance(theme) {
                if (theme === 'light') {
                    document.body.classList.add('light-mode');
                } else {
                    document.body.classList.remove('light-mode');
                }
                localStorage.setItem('appearance', theme);
            }

            function toggleAppearance() {
                const current = localStorage.getItem('appearance') || (window.matchMedia && window.matchMedia('(prefers-color-scheme: light)').matches ? 'light' : 'dark');
                const next = current === 'light' ? 'dark' : 'light';
                applyAppearance(next);
            }

            function deleteHistory() {
                if (!confirm('Delete all local chat history? This will clear messages from this browser session.')) return;
                // Clear chat messages DOM
                const messages = document.getElementById('chatMessages');
                if (messages) messages.innerHTML = '';
                // Clear sessionStorage keys used by the app
                const keysToRemove = ['initialPrompt', 'ocrResult', 'ocrResults', 'chatMode'];
                keysToRemove.forEach(k => sessionStorage.removeItem(k));
                // Optionally clear a chat history item in localStorage
                try { localStorage.removeItem('chatHistory'); } catch (e) {}
                // Show a small confirmation message
                alert('Local chat history cleared.');
            }

            // Attach listeners
            if (settingsBtn) {
                settingsBtn.addEventListener('click', (e) => { e.preventDefault(); openSettings(); });
                settingsBtn.addEventListener('keydown', (e) => { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); openSettings(); } });
            }
            if (closeSettingsBtn) closeSettingsBtn.addEventListener('click', closeSettings);
            if (appearanceToggle) appearanceToggle.addEventListener('click', toggleAppearance);
            if (deleteHistoryBtn) deleteHistoryBtn.addEventListener('click', deleteHistory);

            // Apply initial appearance on load
            document.addEventListener('DOMContentLoaded', () => {
                const saved = localStorage.getItem('appearance');
                if (saved) applyAppearance(saved);
            });
        })();
    </script>
    
    <!-- ATLAS v2.0 Integration -->
    <script src="{{ url_for('static', filename='js/atlas_v2.js') }}?v={{ range(1, 10000) | random }}"></script>
</body>
</html>
